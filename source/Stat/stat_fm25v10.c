
#include "csl\csl_spi.h"
#include "csl\csl_memory.h"
#include "stat_fm25v10.h"

TFM25V10 Eeprom1;
TFM25V10 Eeprom2;

// Коды функций
#define WRSR		0x01
#define WRITE		0x02
#define READ		0x03
#define WRDI		0x04
#define RDSR		0x05
#define WREN 		0x06

// Маска проверкии статусного регистра. Отсекаем бит, который выставлен всегда
#define STATUS_MASK				0xBF
// Маска для самых старших бит
#define ADDRESS_HIGH_MASK		0x10000

//выбор микросхем
//__inline void Eeprom1CsSet(Byte Lev)  {SC_EEPROM1 = Lev;}
//__inline void Eeprom2CsSet(Byte Lev)  {SC_EEPROM2 = Lev;}


void FM25V10_Init(TFM25V10 *p)
{
	p->SpiId   	= SPIA;					// Идентификатор SPI канала (SPIA, SPIB, ...)
	p->SpiBaud 	= SPI_BRR(4000);		// Частота синхроимпульсов
	p->Addr		= 0;					// Адрес
	p->Func		= 0;					// Функция
	p->Count	= 0;					// Количество байт данных
	p->Buffer	= Null;					// Указатель на буфер данных
	p->RdData	= 0;					// Текущий считанный байт
	p->WrData	= 0;					// Текущий записанный байт
	p->State	= 0;					// Текущий шаг выполнения
	p->Error	= false;				// Флаг ошибки в работе памяти
	p->RetryTimer	= 0;				// Таймер повторов перезаписи
	p->RetryCount	= EEPROM_RETRY;		// Количество повторов перезаписи
	p->BusyTimer	= 0;				// Таймер окончания записи
	//p->BusyTime		= WRITE_TIME;		// Максимальное время записи
	//p->CsFunc		= Eeprom1CsSet;		// Функция chip select'а

	p->CsFunc(0);

	p->BusyTimer = 0;
	SPI_init(p->SpiId, SPI_MASTER, 0, p->SpiBaud, 8);
	if (FM25V10_ReadStatus(p)) p->Error = TRUE;				// Статусный регистр должен быть пустой
}

void FM25V10_Update(TFM25V10 *p)
{
	register Uns Tmp;

	if (!p->Func) {p->State = 0; return;}
	
	switch (++p->State)
	{
		case 1:
			if (p->Func & F_READ)    p->State = 2;						// Состояния на 1 больше, т.к. каждый проход switch'а, состояния инкрементируются
			else if (p->Func & F_WRITE)   p->State = 3;
			else {p->Func = 0; p->State = 0;}								// Если функций нет, то обнуляем State
			break;
//-----------------------------------------------------------------
		case 3:															// Чтение байта
			SPI_init(p->SpiId, SPI_MASTER, 0, p->SpiBaud, 8);
			Tmp = FM25V10_ReadByte(p, p->Addr);							// Считываем байт по указанному адресу во временную переменную

			if (!(p->Func & F_WRITE))									// Функция записи отсутствует, значит читаем байт
			{
				if (!(p->Addr & 0x1)) p->RdData = Tmp;					// Текущий адрес четный, значит младшие биты. Записываем в RdData
				else
				{
					p->RdData = (Tmp << 8) | p->RdData;					// Адрес нечетный. Биты старшие. Склеиваем младшие и старшие биты в RdData. Если не будет работать, то нужно будет сделать преведение к Uns
					*((Uns *)p->Buffer) = p->RdData;					// Приводим тип указателя к Uns и записываем данные из RdData в текущую ячейку буфера
				}
			}
			else if (Tmp != p->WrData)									// Если функция записи и считанное значение по адресу, по которому недавно проходила запись не совпадает с данными для записи
			{
				if (++p->RetryTimer < p->RetryCount) p->Func &= ~F_READ;	// Инкрементируем счетчик попыток и проверяем, если ли еще попытки. Если есть, то отсекаем функцию чтения,
																			// чтобы потом по статусу проверить готовность устройства и повторить цикл записи
				else 
				{
					p->Error = TRUE; p->Func = 0;								// Если попытки на перезапись кончились, то выставляем ошибку
				}						
				p->State = 0;
				break;														// Выходим из case
			}
			else {p->RetryTimer = 0; p->Func &= ~F_READ;}					// В остальных случаях обнуляем счетчик попыток и отсекаем функцию чтения
			
			if (p->Count > 1)												// Есть еще байты для записи
			{
				if (p->Buffer && (p->Addr & 0x1))	p->Buffer++;			// Проверяем, что буфер не пустой и что адрес нечетный (первыми считываются младшие биты, затем старшие)
				p->Addr++;
				p->Count--;
			}
			else
			{
				p->RetryTimer = 0;
				p->Count = 0;
				p->Func = 0;
			}

			p->State = 0;
			break;
//-------------------------------------------------------------------------
		case 4:
			if (!p->Buffer) Tmp = 0;					// Буфер пуст
			else Tmp = *((Uns *)p->Buffer);				// Записываем данные из буфера во временную переменную

			if (!(p->Addr & 0x1)) 						// Если 1 - то старшие биты, если 0, то младшие.
				 p->WrData = (Byte)(Tmp & 0xFF);		// Счет адресов идет вверх. Такого - 0011 0000 0000 быть не должно.
														// Продавливаем по маске, для отсечения старших бит и приводим тип к 8-битному
			else p->WrData = (Byte)(Tmp >> 8);			// Сдвигаем старшую часть и приводим к 8-битному типу

			SPI_init(p->SpiId, SPI_MASTER, 0, p->SpiBaud, 8);			// Инициализируем SPI
			FM25V10_WriteEnable(p);										// Посылаем запрос на разрешение записи
			break;
		case 5:
			SPI_init(p->SpiId, SPI_MASTER, 0, p->SpiBaud, 8);			// Инициализируем SPI
			FM25V10_WriteByte(p, p->Addr, p->WrData);					// Пишем байт
			p->Func |= (F_READ);										// Посылка на запись прошла, теперь необходимо проверить правильность записанных данных
																		// по статусному регистру, а так же считать записанные данные для проверки
			p->BusyTimer = 0;											// Сбрасываем таймер, т.к. будем заново проводить проверку готовности
			p->State = 0;
			break;
	}
}



Byte FM25V10_ReadStatus(TFM25V10 *p)
{
	Byte Status;
	
	p->CsFunc(1);
	SPI_send(p->SpiId, RDSR);								// Посылаем код функции на чтение статуса
	Status = SPI_send(p->SpiId, 0);							// Принимаем биты статусного регистра
	p->CsFunc(0);
	
	return Status & STATUS_MASK;
}

void FM25V10_WriteStatus(TFM25V10 *p, Byte Status)
{
	p->CsFunc(1);
	SPI_send(p->SpiId, WRSR);								// Посылаем код функции на запись в статусный регистр
	SPI_send(p->SpiId, Status);								// Посылаем данные для записи в статусный регистр
	p->CsFunc(0);
}

Byte FM25V10_ReadByte(TFM25V10 *p, unsigned long Addr)
{
	Byte Data;
	
	p->CsFunc(1);
	SPI_send(p->SpiId, READ);								// Посылаем код функции на чтение байта
	SPI_send(p->SpiId, (Addr & ADDRESS_HIGH_MASK) >> 16);	// Addr >> 16
	SPI_send(p->SpiId, (Addr >> 8) & 0xFF);					// Посылаем сперва старшие биты адреса
	SPI_send(p->SpiId, Addr & 0xFF);						// Затем младшие биты адреса
	Data = SPI_send(p->SpiId, 0);
	p->CsFunc(0);

	return Data;											// Возвращаем прочтенный байт данных
}

void FM25V10_WriteByte(TFM25V10 *p, unsigned long Addr, Byte Data)
{
	p->CsFunc(1);

	SPI_send(p->SpiId, WRITE);								// Посылаем код функции на запись
	SPI_send(p->SpiId, (Addr & ADDRESS_HIGH_MASK) >> 16);	// Addr >> 16
	SPI_send(p->SpiId, Addr >> 8);							// Посылаем сперва старшие биты адреса
	SPI_send(p->SpiId, Addr);								// Затем младшие биты адреса
	SPI_send(p->SpiId, Data);								// Посылаем байт на запись
	p->CsFunc(0);
}

void FM25V10_WriteEnable(TFM25V10 *p)
{
	p->CsFunc(1);
	SPI_send(p->SpiId, WREN);								// Посылаем код функции на включение записи
	p->CsFunc(0);
}

void FM25V10_WriteDisable(TFM25V10 *p)
{
	p->CsFunc(1);
	SPI_send(p->SpiId, WRDI);								// Посылаем код функции на запрещение записи
	p->CsFunc(0);
}

